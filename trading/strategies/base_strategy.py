"""
üìä Base Strategy - Classe de Base pour les Strat√©gies
Classe abstraite pour toutes les strat√©gies de trading
"""

from abc import ABC, abstractmethod
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import uuid
import logging
import pandas as pd

from core.logger import get_logger
from ..engine.execution_handler import TradingSignal, SignalType

logger = get_logger(__name__)


class StrategyStatus(Enum):
    """Status d'une strat√©gie"""
    INACTIVE = "inactive"
    ACTIVE = "active"
    PAUSED = "paused"
    ERROR = "error"


@dataclass
class StrategyMetrics:
    """M√©triques d'une strat√©gie"""
    total_signals: int = 0
    buy_signals: int = 0
    sell_signals: int = 0
    hold_signals: int = 0
    successful_trades: int = 0
    failed_trades: int = 0
    total_pnl: float = 0.0
    win_rate: float = 0.0
    average_trade_duration: float = 0.0  # en heures
    max_drawdown: float = 0.0
    
    def update_win_rate(self):
        """Met √† jour le win rate"""
        total_trades = self.successful_trades + self.failed_trades
        self.win_rate = (self.successful_trades / max(1, total_trades)) * 100
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "total_signals": self.total_signals,
            "buy_signals": self.buy_signals,
            "sell_signals": self.sell_signals,
            "hold_signals": self.hold_signals,
            "successful_trades": self.successful_trades,
            "failed_trades": self.failed_trades,
            "total_pnl": self.total_pnl,
            "win_rate": self.win_rate,
            "average_trade_duration": self.average_trade_duration,
            "max_drawdown": self.max_drawdown
        }


class BaseStrategy(ABC):
    """
    Classe de base abstraite pour toutes les strat√©gies de trading
    D√©finit l'interface commune et les fonctionnalit√©s de base
    """
    
    def __init__(self, name: str, symbol: str, timeframe: str = "1h", parameters: Optional[Dict] = None):
        # Identifiants
        self.strategy_id: str = str(uuid.uuid4())
        self.name: str = name
        self.symbol: str = symbol.upper()
        self.timeframe: str = timeframe
        
        # Param√®tres
        self.parameters: Dict[str, Any] = parameters or {}
        self.default_parameters: Dict[str, Any] = self.get_default_parameters()
        
        # Status et m√©triques
        self.status: StrategyStatus = StrategyStatus.INACTIVE
        self.metrics: StrategyMetrics = StrategyMetrics()
        
        # Historique
        self.signal_history: List[TradingSignal] = []
        self.data_cache: Optional[pd.DataFrame] = None
        
        # Configuration
        self.created_at: datetime = datetime.now(timezone.utc)
        self.last_signal_at: Optional[datetime] = None
        
        # Fusion des param√®tres par d√©faut avec les param√®tres fournis
        self._merge_parameters()
        
        logger.info(f"Strat√©gie {self.name} cr√©√©e - ID: {self.strategy_id}, Symbol: {self.symbol}")
    
    @abstractmethod
    def get_default_parameters(self) -> Dict[str, Any]:
        """
        Retourne les param√®tres par d√©faut de la strat√©gie
        √Ä impl√©menter dans chaque strat√©gie
        """
        pass
    
    @abstractmethod
    def generate_signal(self, data: pd.DataFrame) -> TradingSignal:
        """
        G√©n√®re un signal de trading bas√© sur les donn√©es
        √Ä impl√©menter dans chaque strat√©gie
        
        Args:
            data: DataFrame avec colonnes ['timestamp', 'open', 'high', 'low', 'close', 'volume']
            
        Returns:
            TradingSignal: Signal g√©n√©r√©
        """
        pass
    
    @abstractmethod
    def calculate_position_size(self, signal: TradingSignal, account_balance: float) -> float:
        """
        Calcule la taille de position pour un signal
        √Ä impl√©menter dans chaque strat√©gie
        
        Args:
            signal: Signal de trading
            account_balance: Solde du compte
            
        Returns:
            float: Taille de position recommand√©e
        """
        pass
    
    @abstractmethod
    def should_exit(self, position: Dict[str, Any], current_data: pd.DataFrame) -> bool:
        """
        D√©termine si une position doit √™tre ferm√©e
        √Ä impl√©menter dans chaque strat√©gie
        
        Args:
            position: Dictionnaire avec les infos de position
            current_data: Donn√©es de march√© actuelles
            
        Returns:
            bool: True si la position doit √™tre ferm√©e
        """
        pass
    
    def activate(self):
        """Active la strat√©gie"""
        if self.status == StrategyStatus.INACTIVE:
            self.status = StrategyStatus.ACTIVE
            logger.info(f"Strat√©gie {self.name} activ√©e")
        else:
            logger.warning(f"Strat√©gie {self.name} d√©j√† active ou en erreur")
    
    def deactivate(self):
        """D√©sactive la strat√©gie"""
        self.status = StrategyStatus.INACTIVE
        logger.info(f"Strat√©gie {self.name} d√©sactiv√©e")
    
    def pause(self):
        """Met en pause la strat√©gie"""
        if self.status == StrategyStatus.ACTIVE:
            self.status = StrategyStatus.PAUSED
            logger.info(f"Strat√©gie {self.name} en pause")
    
    def resume(self):
        """Reprend la strat√©gie"""
        if self.status == StrategyStatus.PAUSED:
            self.status = StrategyStatus.ACTIVE
            logger.info(f"Strat√©gie {self.name} reprise")
    
    def process_market_data(self, data: pd.DataFrame) -> Optional[TradingSignal]:
        """
        Traite les donn√©es de march√© et g√©n√®re un signal si n√©cessaire
        
        Args:
            data: DataFrame avec les donn√©es de march√©
            
        Returns:
            Optional[TradingSignal]: Signal g√©n√©r√© ou None
        """
        try:
            if self.status != StrategyStatus.ACTIVE:
                return None
            
            # Validation des donn√©es
            if not self._validate_data(data):
                logger.warning(f"Donn√©es invalides pour strat√©gie {self.name}")
                return None
            
            # Cache des donn√©es
            self.data_cache = data.copy()
            
            # G√©n√©ration du signal
            signal = self.generate_signal(data)
            
            if signal:
                # Mise √† jour des m√©triques
                self._update_signal_metrics(signal)
                
                # Ajout √† l'historique
                self.signal_history.append(signal)
                self.last_signal_at = datetime.now(timezone.utc)
                
                logger.info(f"Signal g√©n√©r√© par {self.name}: {signal.signal_type.value} pour {signal.symbol}")
            
            return signal
            
        except Exception as e:
            logger.error(f"Erreur traitement donn√©es par {self.name}: {str(e)}")
            self.status = StrategyStatus.ERROR
            return None
    
    def update_parameters(self, new_parameters: Dict[str, Any]):
        """Met √† jour les param√®tres de la strat√©gie"""
        try:
            # Validation des param√®tres
            validated_params = self._validate_parameters(new_parameters)
            
            # Mise √† jour
            self.parameters.update(validated_params)
            
            logger.info(f"Param√®tres mis √† jour pour {self.name}: {validated_params}")
            
        except Exception as e:
            logger.error(f"Erreur mise √† jour param√®tres {self.name}: {str(e)}")
            raise
    
    def get_strategy_info(self) -> Dict[str, Any]:
        """Retourne les informations compl√®tes de la strat√©gie"""
        return {
            "strategy_id": self.strategy_id,
            "name": self.name,
            "symbol": self.symbol,
            "timeframe": self.timeframe,
            "status": self.status.value,
            "parameters": self.parameters,
            "metrics": self.metrics.to_dict(),
            "created_at": self.created_at.isoformat(),
            "last_signal_at": self.last_signal_at.isoformat() if self.last_signal_at else None,
            "signal_count": len(self.signal_history)
        }
    
    def get_recent_signals(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Retourne les signaux r√©cents"""
        try:
            # Trier par timestamp d√©croissant
            sorted_signals = sorted(
                self.signal_history,
                key=lambda x: x.timestamp,
                reverse=True
            )
            
            # Limiter les r√©sultats
            recent_signals = sorted_signals[:limit]
            
            return [signal.to_dict() for signal in recent_signals]
            
        except Exception as e:
            logger.error(f"Erreur r√©cup√©ration signaux r√©cents {self.name}: {str(e)}")
            return []
    
    # M√©thodes utilitaires communes
    def _merge_parameters(self):
        """Fusionne les param√®tres par d√©faut avec ceux fournis"""
        merged_params = self.default_parameters.copy()
        merged_params.update(self.parameters)
        self.parameters = merged_params
    
    def _validate_data(self, data: pd.DataFrame) -> bool:
        """Valide les donn√©es de march√©"""
        if data is None or data.empty:
            return False
        
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        for col in required_columns:
            if col not in data.columns:
                logger.error(f"Colonne manquante dans les donn√©es: {col}")
                return False
        
        # V√©rification des valeurs nulles
        if data[required_columns].isnull().any().any():
            logger.warning("Valeurs nulles d√©tect√©es dans les donn√©es")
            return False
        
        return True
    
    def _validate_parameters(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Valide les param√®tres (√† surcharger dans les sous-classes)
        """
        # Validation de base - √† √©tendre dans les strat√©gies sp√©cifiques
        validated = {}
        for key, value in parameters.items():
            if key in self.default_parameters:
                validated[key] = value
            else:
                logger.warning(f"Param√®tre inconnu ignor√©: {key}")
        
        return validated
    
    def _update_signal_metrics(self, signal: TradingSignal):
        """Met √† jour les m√©triques bas√©es sur le signal"""
        self.metrics.total_signals += 1
        
        if signal.signal_type == SignalType.BUY:
            self.metrics.buy_signals += 1
        elif signal.signal_type == SignalType.SELL:
            self.metrics.sell_signals += 1
        else:
            self.metrics.hold_signals += 1
    
    def calculate_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calcule les indicateurs techniques communs
        Peut √™tre utilis√© par les strat√©gies d√©riv√©es
        """
        try:
            df = data.copy()
            
            # Moving Averages
            df['SMA_10'] = df['close'].rolling(window=10).mean()
            df['SMA_20'] = df['close'].rolling(window=20).mean()
            df['EMA_12'] = df['close'].ewm(span=12).mean()
            df['EMA_26'] = df['close'].ewm(span=26).mean()
            
            # MACD
            df['MACD'] = df['EMA_12'] - df['EMA_26']
            df['MACD_signal'] = df['MACD'].ewm(span=9).mean()
            df['MACD_histogram'] = df['MACD'] - df['MACD_signal']
            
            # RSI
            delta = df['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            df['RSI'] = 100 - (100 / (1 + rs))
            
            # Bollinger Bands
            df['BB_middle'] = df['close'].rolling(window=20).mean()
            bb_std = df['close'].rolling(window=20).std()
            df['BB_upper'] = df['BB_middle'] + (bb_std * 2)
            df['BB_lower'] = df['BB_middle'] - (bb_std * 2)
            
            return df
            
        except Exception as e:
            logger.error(f"Erreur calcul indicateurs: {str(e)}")
            return data
    
    def __str__(self) -> str:
        return f"{self.name}({self.symbol}-{self.timeframe})"
    
    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}: {self.name} [{self.status.value}]>"